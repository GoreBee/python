import timeit

def r_func(n1,c):

    n = c
    a = [0] * n  # создание массива с n количеством элементов
    for i in range(n):  # заполнение массива ...
        a[i] = i  # значениями от 0 до n-1


    a[1] = 0

    m = 2  # замена на 0 начинается с 3-го элемента (первые два уже нули)
    while m < n:  # перебор всех элементов до заданного числа
        if a[m] != 0:  # если он не равен нулю, то
            j = m * 2  # увеличить в два раза (текущий элемент - простое число)
            while j < n:
                a[j] = 0  # заменить на 0
                j = j + m  # перейти в позицию на m больше
        m += 1
  
    b = []
    for i in a:
        if a[i] != 0:
            b.append(a[i])

    del a
    return b[n1-1]

def c_func(n):
    n1=1
    m=2
    j=2
    while n1<n:
        j+=1
        flag = True
        for i in range(2,j):
            if j % i ==0:
                flag = False
                break
        if flag:
            n1+=1
            m=j
    return m

n = int(input("Введите индекс простого числа: "))

c = (c_func(n))
c1=c+2
r = r_func(n,c1)
ctime = timeit.timeit("c_func(n)", number = 1000,globals=globals())
print(f"Без использования решета: {c}. Оценка timeit: {ctime}")

rtime = timeit.timeit("r_func(n,c1)", number = 1000 , globals = globals())
print(f"C использованием решета: {r}. Оценка timeit: {rtime}")

"""
Использование алгоритма с решетом значительно ускоряет выполнение программы, особенно для больших N
n= 5
Без использования решета: 11. Оценка timeit: 0.009851897000000331
C использованием решета: 11. Оценка timeit: 0.012897247000000167 - пока выигрыша от решета нет

n=10
Без использования решета: 29. Оценка timeit: 0.03244011499999999
C использованием решета: 29. Оценка timeit: 0.029682447999999972 - алгоритмы сравнялись по производительности

n=100
Без использования решета: 541. Оценка timeit: 1.1873259480000016
C использованием решета: 541. Оценка timeit: 0.16931875299999888 - алгоритм с решетом уже существенно выигрывает

n=1000
Без использования решета: 7919. Оценка timeit: 207.06658938599998
C использованием решета: 7919. Оценка timeit: 2.9515685140000016 - алгоритм с решетом работает несравненно быстрее


"""